# 设计模式

## 单例模式

## 桥接模式/接口模式

对于多维特征的一些对象，比如在实现多系统上播放多种格式的视频文件的播放器。一种方法是通过继承：

先有一个播放器的父类，然后扩展第一维的子类，对不同操作系统支持的播放器；然后再扩展下一类的子类，支持不同的文件。这种方法会创建特别多的类，同时子类和父类有强耦合关系，不方便扩展系统。另一种方式就是将第二层级的父类子类关系，转为依赖关系，在父类里面依赖不同视频的文件接口，这样通过接口定义很多视频文件的操作，并且也能通过依赖注入的方式配置播放器处理的视频文件信息。

## 适配器模式

对于目标类接口的转换器，提供客户需要的接口，有点。主要的角色有包装类(Adapter)以及被包装的对象（Adaptee），这里用户需要的接口可以看作一个Target接口，所以典型的Adapter的样例，可以是继承Adaptee对象，然后去实现Target接口:

```
public class Adapter extends Adaptee implements Target{
	...
}
```

## 责任链模式

在实际场景中，通常由于管理的分级，会存在相邻级别直接的请求传递，这种直接传递请求给特定的对象，会造成高耦合；只要责任划分确定了后，那么我可以直接提交请求到责任链上，后续的处理过程由责任链调度其它责任人处理。由于责任链的链表结构，可以通过链表来表示该结构。每个Handler都有下一个该处理任务的Handler接口，具体的Handler接口实现由需求来决定。

```
public abstrac class Handler{
	protected Handler successor;
	public void setSuccessor(Handler handler){
	this.successor = handler;
	}
	public abstract void handlerRequest(Request req);
}
```



具体的例子可以在审批流程里面，合同审核，在不同的情况下，需要不同领导来处理。比如合同金额10万以下可以交给部门经理审核，合同金额10万~100万交给区域经理审核，合同金额100万以上要交给总经理审核。这种就可以使用责任链模式，还有Web编程里面的Filter也是采用的责任链模式。

## 中介者模式

对象之间存在复杂的引用情况，引入中介者模式降低复杂度，对象之间的交互通过中介（Mediator）来统一协作，从而减少交互的次数，能够复用很多资源。参与的对象都可以看成(Colleague)，那么中介需要维护一个参与者的列表，然后当请求来了之后，就根据请求调用相关的对象的方法。

具体应用例子可以在聊天室程序里面看到，任意对象之间会发送消息。

## 观察者模式

一对多的关系，一个对象发生变化后，所有依赖该对象的都会得到通知，关键的角色有目标（Subject）和观察者（Observer）;

那么也就是说，目标里面需要维护一个观察者的列表，并且提供观察者的添加和删除，并且如果对象发生改变，就要依次通知所有的观察者，告诉他们需要更新依赖的目标对象（观察者会依赖目标对象），观察者根据通知来执行对应的更新操作。

