## 一、算法的定义和特征

1）算法是什么？求解特定问题的一组有穷规则的集合，它是由若干条指令组成的有穷符号串。
2）算法5个特性：确定性，可实现性，输入，输出，有穷性
3）算法设计的质量指标：正确性，可读性，健壮性，效率与存储量
4）不是所有的计算机程序都是算法

## 二、算法复杂度

$O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3)$
$O(2^n) < O(n!) < O(n^n)$

## 三、常见算法

### 3.1 递归
1） 直接或者间接调用自身的算法为递归算法

## 分治法

**思想**：将一个难以直接解决的大问题分割为一些规模较小的相同问题，以便各个击破，分而治之。
**条件**：
1. 小规模问题很容易解
2. 最优自子结构
3. 子问题的解可以合并为原问题解
4. 各个子问题相互独立
**步骤**：
1. 分解 
2. 解决
3. 合并

## Master定理

设常数$a >= 1, b > 1，f(n)为函数$
T(n)为非负函数，$T(n) = aT(n/b) + f(n)$,则有：
1. 若$f(n) = O(n^{log_b^{(a-\theta)}}), \theta > 0$,则 $T(n)=\Theta(n^{log_b^a})$
2. 若$f(n) = \Theta(n^{log_b^a})$, 则$T(n) = \Theta(n^{log_b^a}logn)$
3. 若$f(n) = \Omega(n^{logb^{a+\theta}}),\theta > 0;且当n充分大时有 af(n/b) \leqslant cf(n)$, 则 $T(n) = \Theta(f(n))$

## 常见分治排序的算法：

1. 合并排序
```
1）排序左边，排序右边
2）合并左右的排序结果到新数组
3) 复制合并结果到源数组

```

2. 快速排序
```
1) 选取主元
2）将大于主元的元素放在右边，小于主元的放在左边（partition）
3）快速排序左半部分，快速排序右半部分
```
partition核心代码：
```
int i = p, j = r+1; // 首尾
int x = a[p];
while(true){
    while(a[--j] > x); // 从右开始找小于等于主元的数
    swap(a[i], a[j]);
    while(a[++i] <= x && i < r); // 从左开始找大于主元的数
    if(i >= j) break;
    swap(a[i], a[j]);
}
return j;
```
3. 循环赛，日程表设计，n个选手分割为两半，然后为n/2个选手安排（按对角线堆成），当分割为只有两个的时候，直接进行比赛。

## 动态规划算法

**思想：** 把求解的问题分成许多阶段或多个子问题，然后按顺序求解各个子问题。通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。

**要素：** 1)最优子结构性质；2) 子问题重叠性质

**基本步骤:**
1）找出最优解的性质
2) 递归的定义最优值
3) 自底向上计算最优质
4）根据计算最优值时得到的信息，构造最优解

## 动态规划常见问题

1）矩阵连乘的最优计算次序，使得复杂度最小
问题建模：A[i:j],表示矩阵连乘积，要计算A[i:j]的复杂度，如果在$A_k$和$A_{k+1}$断开（一种加括号的方式）：
$(A_i,A_{i+1}....A_k)(A_{k+1}A_{k+2}...A_j)$

计算量：$A[i:k]$的计算量，加上$A[k+1:j]$的计算量，再加上$A[i:k]$和$A[k+1:j]$相乘的计算量。目标是求最优加括号方式得到，最小的计算复杂度，目标还是的求复杂度，则要寻找求解矩阵连乘问题复杂度的一个最优子结构。（不同的加括号方式有不同的复杂度）

**【递归关系】**
$i=j，m[i][j] = 0;$
$i < j; m[i][j] = \min_{i \leqslant k < j}\{m[i][k] + m[k+1][j]\} + p_{i-1}p_kp_j$
计算次序：沿着对角线计算，方法如下：
```
for(int r=2; r <= n; r++){
    for(int i=1; i <= n-r+1; i++){
        int j = i+r-1;
        ....
    }
}
```

2）最长公共子序列问题（LCS）

子序列:某个序列删去若干元素得到的序列

c[i][j]表示Xi和Yj的最长公共子序列的长度。

目标求两个序列的最长公共子序列。变量：长度。
**递归结构**
$c[i][j]=\left\{\begin{matrix}
 0&i=0,j=0 \\ 
 c[i-1][j-1]+1&i,j>0; x_i=y_j \\ 
 max\{c[i][j-1],c[i-1][j]\}& i,j>0;x_i\neq y_j 
\end{matrix}\right.$

关键点：在于如何发现最优的子结构，逐步小规模化问题（问题能不断往规模小的方向划分，最后到达易解的情况）

**3）最大子段和（O(n)）**
求n个整数组成的序列中，连续的一段的最大和：
**[递归结构]**
$b[j] = \max\{b[j-1] + a[j], a[j]\}$


**4）图像压缩问题**

像素序列需要的存储空间：
N[i] 第i组中像素的个数
b[i] 第i组中，每个像素表示需要的最短位数

$\sum_{i=1}^m N[i]b[i]+11m$


## 贪心算法

基本要素：
1）最优子结构
2）当前状态下做出最好的选择
3）自顶向下

**1.活动安排问题**
k个活动，每个活动的开始和结束时间分别为sk，fk，sk<fk，从活动集合中选择最大的相容活动子集。（活动数目最多）

方法：**先结束的优先安排，然后寻找相容的活动。**

**2.背包问题（0-1背包问题不能用贪心求解）**

背包问题可以装入物品的一部分，不用全部装完；所以贪心策略为，**按单位重量价值最高的优先装入**。

3.单源最短路径问题

求源到所有其它各顶点的最短路径长度（非负权值）

$S$集合与$d[i]$数组的不断更新，$d[i]$表示源到所有顶点$v_i$的最小距离。
初始化方法：如果有直接边就是权值，没有直接边就是无穷。
然后每次找$d[i]$中最小值对应的顶点加入$S$集合，同时，根据该顶点相邻的其它顶点，更新源到其它顶点的最小距离，更新方法：
如果有一条边$<v_i,v_j>$，权值为 $w_{ig}$，则有:
$$d[j] = min(d[i] + w_{ij}, d[j])$$ 

## 回溯法

解空间用解空间树的形式来表示，根节点在第一层，表示搜索初始状态，第二层对应解向量的第一个分量做出选择后到达的状态，第一层到第二层的边上标出对第一个分量选择的结果，后面依次类推。

**基本思想：**
回溯法从根节点出发，按照深度优先策略遍历解空间树，搜索满足约束条件的解，初始时，根节点为一个活节点（也称为当前扩展节点），活节点向深处搜索新节点，如果新节点满足约束，该新节点为新的扩展节点。如果深入过程中遇到不满足约束的节点（死节点），就要回溯到最近的一个活节点。
1. **用约束条件剪去得不到可行解的子树**
2. **用限界函数剪去得不到最优解的子树**

**求解过程**
1. 定义问题的解空间
2. 确定易于搜索的解空间结构
3. 深度优先搜索解空间，并且在搜索中用剪枝函数避免无效搜索。

**子集树**
当所给的问题是从$n$个元素的集合$S$中找出满足某种性质的**子集**时，解空间为**子集树**，遍历需要$O(2n)$
当所给的问题是从$n$个元素的集合$S$中找出满足某种性质的**排列**时，解空间树为**排列树**，遍历需要$O(n!)$

（1）装载问题，
**问题：** n个集装箱要装上2艘载重量分别为c1和c2的轮船，确定是否存在一种装载方案，使得2艘轮船能够装上n个集装箱。

**策略：** 第一个集装箱尽量装满，然后剩余货物装到第二个集装箱里面，等价于一个$0-1$背包问题：
$$\sum_{i=1}^nw_ix_i\leqslant c_1, x_i \epsilon \{0,1\}, 1\leqslant i\leqslant n$$

**子集树算法框架**
```
// h(i) 表示当前扩展节点处x[t]的第i个可选值。
void backtrack(int t){ // 当前扩展节点在解空间树的深度
    if(t > n) output(x); // 搜索到叶子节点停止了
    else // f(n.t) 当前扩展节点处未搜索过的子树的起始编号
        // g(n,t) 当前扩展节点处未搜素过的子树的终止编号
        // 对扩展节点所有可能进行枚举
        for(int i=f(n,t);i <= g(n,t); i++){ 
            x[t] = h[i];
            if(constraint(t) && bound(t)) 
                backtrack(t+1);
        }
}
```
**排列树算法框架**
```
void backtrack(int t){
    if(t > n) output(x);
    else
        for(int i = t; i < n; i++){
            // 每一层的几种选择
            swap(x[t], x[i]);
            // 深入下一层
            if (constraint(t) && bound(t)) backtrack(t+1);
            // 回溯返回上一层状态
            swap(x[t], x[i]); 
        }
}
```

排列树：旅行商问题，经过每个城市，然后回到起点，让总开销最少。

backtrack(1)，表示对1...n进行全排列

**子集树或者排列树：N皇后问题**

解表示为$x[i]$ ，表示第i行对应放置的皇后的列的位置。

约束1：任意两个皇后不同列：$x_i\neq x_j$
约束2：任意两个皇后不在对角线：$|i-j|\neq |x_i-x_j|$

n皇后限界函数
```
bool Bound(int k){
    for(int i = 1; i < k; i ++){
        if(abs(k-i) == abs(x[i] - x[k]) || x[i] == x[k])
            return false;
    }
    return true;
}
```

## 分支界限法

（1）FIFO分支限界法
（2）优先队列式分支限界法

0-1背包求解，使用分支界限法，求上下界。上界为：剩余容量最大价值
单源最短路径